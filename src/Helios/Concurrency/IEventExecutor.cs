using System;
using System.Threading;
using System.Threading.Tasks;

namespace Helios.Concurrency
{
    /// <summary>
    /// Executes events generated by Helios channels and transports
    /// </summary>
    public interface IEventExecutor
    {
        /// <summary>
        /// Returns <c>true</c> if the current <see cref="Thread"/> belongs to this event loop,
        /// <c>false</c> otherwise.
        /// </summary>
        /// <remarks>
        /// Used to determine if we can safely execute an operation or not, or if we need to schedule 
        /// it in the future.
        /// </remarks>
        bool InEventLoop { get; }

        /// <summary>
        /// Checks to see if this <see cref="IEventExecutor"/> is executing inside the given thread
        /// </summary>
        bool IsInEventLoop(Thread thread);

        /// <summary>
        /// Gets a <see cref="Task"/> object that completes once this <see cref="IEventExecutor"/> has been terminated.
        /// </summary>
        Task TerminationTask { get; }

        /// <summary>
        /// <c>true</c> if this <see cref="IEventExecutor"/> is in the process of being terminated.
        /// </summary>
        bool IsShuttingDown { get; }

        /// <summary>
        /// <c>true</c> if this <see cref="IEventExecutor"/> has finished shutting down.
        /// </summary>
        bool IsShutDown { get; }

        /// <summary>
        /// Returns <c>true</c> if all tasks have completed following shut down.
        /// </summary>
        bool IsTerminated { get; }



        Task GracefulShutdownAsync();

        Task GracefulShutdownAsync(TimeSpan quietPeriod, TimeSpan timeout);
    }
}
